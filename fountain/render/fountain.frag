"#version 130\n"
"\n"
"const int RENDER_PLAIN = 0;\n"
"const int RENDER_BLUR = 1;\n"
"const int RENDER_BASIC = 2;\n"
"const int RENDER_HDR = 3;\n"
"const int RENDER_FINAL = 4;\n"
"\n"
"const float eps = 0.00001;\n"
"const float Pi = 3.14159265358979323846;\n"
"const vec3 LuminanceVector = vec3(0.2125, 0.7154, 0.0721);\n"
"\n"
"const float DefaultSpotCosCutOff = 0.97;\n"
"const float DefaultSpotExponent = 5.0;\n"
"const int LightMaxNum = 64;\n"
"const int POINT_LIGHT = 0;\n"
"const int DIRECTIONAL_LIGHT = 1;\n"
"const int SPOT_LIGHT = 2;\n"
"\n"
"//Engine\n"
"uniform int feiRenderMode;\n"
"uniform vec2 feiMouse;\n"
"uniform float feiTime;\n"
"uniform vec3 feiViewCoord;\n"
"\n"
"out vec4 feiColorOutput;\n"
"out vec4 feiEmitOutput;\n"
"\n"
"//Basic\n"
"uniform bool feiUseTex;\n"
"uniform bool feiUseEmitTex;\n"
"uniform bool feiUseNormalTex;\n"
"uniform bool feiUseCullTex;\n"
"uniform bool feiUseLight;\n"
"\n"
"uniform sampler2D feiTex;\n"
"uniform sampler2D feiEmitTex;\n"
"uniform sampler2D feiNormalTex;\n"
"uniform sampler2D feiCullTex;\n"
"\n"
"uniform vec3 feiNormalValue;\n"
"\n"
"//Blur\n"
"uniform float feiBlurRadius;\n"
"uniform float feiSampleNum;\n"
"\n"
"//Material\n"
"uniform vec3 feiKd; // Cdiff/Pi\n"
"uniform vec3 feiKs; // ((m+8)/8Pi)Cspec\n"
"uniform float feiSmoothness;\n"
"uniform float feiEmitValue;\n"
"float feiEmitHaloValue = 0.5;\n"
"uniform float feiEmitAllValue;\n"
"\n"
"//Light Source\n"
"uniform int feiLightNum;\n"
"uniform int feiLightType[LightMaxNum];\n"
"uniform vec3 feiLightPos[LightMaxNum];\n"
"uniform vec3 feiLightDirection[LightMaxNum];\n"
"uniform vec4 feiLightColor[LightMaxNum];\n"
"uniform float feiLightRadius[LightMaxNum];\n"
"\n"
"//HDR\n"
"uniform float feiLw; //HDR\n"
"uniform float feiLwhite;\n"
"\n"
"in vec4 v_color;\n"
"in vec2 v_texcoord;\n"
"in vec3 v_worldcoord;\n"
"\n"
"vec3 g_ViewDirection = normalize(v_worldcoord - feiViewCoord);\n"
"float g_gamma = 2.2;\n"
"\n"
"//Utility\n"
"vec3 getNormalFromNormalMap(sampler2D normalMap, vec2 texCoord, mat3 normalMatrix);\n"
"vec4 blur(sampler2D texture, vec2 texCoord, float blurRadius, float sampleNum);\n"
"\n"
"void rgb2hsv(inout vec3 color);\n"
"void hsv2rgb(inout vec3 color);\n"
"\n"
"void rgb2hsl(inout vec3 color);\n"
"void hsl2rgb(inout vec3 color);\n"
"\n"
"void rgb2linear(inout vec3 rgb);\n"
"void linear2rgb(inout vec3 linear);\n"
"\n"
"float getLuminance(vec4 color);\n"
"\n"
"void DirectionalLight(inout vec4 result, vec4 texColor, vec3 normal, vec3 lightDirection, vec3 lightColor, float lightIntensity);\n"
"void PointLight(inout vec4 result, vec4 texColor, vec3 normal, vec3 lightPos, float lightRadius, vec3 lightColor, float lightIntensity);\n"
"void SpotLight(inout vec4 result, vec4 texColor, vec3 normal, vec3 lightPos, vec3 lightDirection, float lightRadius, float lightCosCutOff, vec3 lightColor, float lightIntensity);\n"
"float ToneMap(float Lw);\n"
"\n"
"//Render Pass\n"
"void renderPlain();\n"
"void renderBlur();\n"
"void renderBasic();\n"
"void renderHDR();\n"
"void renderFinal();\n"
"\n"
"void main()\n"
"{\n"
"	switch (feiRenderMode) {\n"
"	case RENDER_PLAIN:\n"
"		renderPlain();\n"
"		break;\n"
"	case RENDER_BLUR:\n"
"		renderBlur();\n"
"		break;\n"
"	case RENDER_BASIC:\n"
"		renderBasic();\n"
"		break;\n"
"	case RENDER_HDR:\n"
"		renderHDR();\n"
"		break;\n"
"	case RENDER_FINAL:\n"
"		renderFinal();\n"
"		break;\n"
"	default:\n"
"		renderPlain();\n"
"		break;\n"
"	}\n"
"}\n"
"\n"
"vec3 getNormalFromNormalMap(sampler2D normalMap, vec2 texCoord, mat3 normalMatrix)\n"
"{\n"
"	vec3 ret = vec3(texture2D(normalMap, texCoord));\n"
"	ret *= 2.0;\n"
"	ret -= vec3(1.0);\n"
"	ret.r *= -1.0;\n"
"	ret = normalize(normalMatrix * ret);\n"
"	return ret;\n"
"}\n"
"\n"
"void PointLight(inout vec3 result, vec3 texColor, vec3 normal, vec3 lightPos, float lightRadius, vec3 lightColor, float lightIntensity)\n"
"{\n"
"	if (lightIntensity == 0.0) {\n"
"		return;\n"
"	}\n"
"	vec3 pl = lightPos;\n"
"	vec3 El = lightColor * lightIntensity;\n"
"	float m = feiSmoothness;\n"
"	vec3 p = v_worldcoord;\n"
"\n"
"	vec3 n = normal;\n"
"	vec3 l = pl - p;\n"
"	float len = length(l);\n"
"	l = l / len;\n"
"	vec3 v = -g_ViewDirection;\n"
"	vec3 h = normalize(l + v);\n"
"\n"
"	float cosThetai = max(dot(n, l), 0.0);\n"
"	float cosThetah = 0.0;\n"
"	if (cosThetai != 0.0) {\n"
"		cosThetah = max(dot(n, h), 0.0);\n"
"	} else {\n"
"		return;\n"
"	}\n"
"	float attenuation = 1.0 / pow((len / lightRadius) + 1.0, 2.0);\n"
"	vec3 L0 = (feiKd * texColor + feiKs * pow(cosThetah, m)) * (El * cosThetai * attenuation);\n"
"	result += L0;\n"
"}\n"
"\n"
"void DirectionalLight(inout vec3 result, vec3 texColor, vec3 normal, vec3 lightDirection, vec3 lightColor, float lightIntensity)\n"
"{\n"
"	if (lightIntensity == 0.0) {\n"
"		return;\n"
"	}\n"
"	vec3 El = lightColor * lightIntensity;\n"
"	float m = feiSmoothness;\n"
"\n"
"	vec3 n = normal;\n"
"	vec3 l = -lightDirection;\n"
"	float len = length(l);\n"
"	l = l / len;\n"
"	vec3 v = vec3(0.0, 0.0, 1.0);\n"
"	vec3 h = normalize(l + v);\n"
"\n"
"	float cosThetai = max(dot(n, l), 0.0);\n"
"	float cosThetah = 0.0;\n"
"	if (cosThetai != 0.0) {\n"
"		cosThetah = max(dot(n, h), 0.0);\n"
"	} else {\n"
"		return;\n"
"	}\n"
"	vec3 L0 = (feiKd * texColor + feiKs * pow(cosThetah, m)) * (El * cosThetai);\n"
"	result += L0;\n"
"}\n"
"\n"
"void SpotLight(inout vec3 result, vec3 texColor, vec3 normal, vec3 lightPos, vec3 lightDirection, float lightRadius, float lightCosCutOff, vec3 lightColor, float lightIntensity)\n"
"{\n"
"	if (lightIntensity == 0.0) {\n"
"		return;\n"
"	}\n"
"	vec3 pl = lightPos;\n"
"	vec3 El = lightColor * lightIntensity;\n"
"	float m = feiSmoothness;\n"
"	vec3 p = v_worldcoord;\n"
"\n"
"	vec3 n = normal;\n"
"	vec3 l = pl - p;\n"
"	float len = length(l);\n"
"	l = l / len;\n"
"	vec3 v = -g_ViewDirection;\n"
"	vec3 h = normalize(l + v);\n"
"\n"
"	float cosThetai = max(dot(n, l), 0.0);\n"
"	float cosThetah = 0.0;\n"
"	if (cosThetai != 0.0) {\n"
"		cosThetah = max(dot(n, h), 0.0);\n"
"	} else {\n"
"		return;\n"
"	}\n"
"	float attenuation = 1.0 / pow((len / lightRadius) + 1.0, 2.0);\n"
"	float spotCos = dot(l, -lightDirection);\n"
"	float cutOffFadeOut = (1.0 - lightCosCutOff) * 2.0;\n"
"	float secondCosCutOff = lightCosCutOff - cutOffFadeOut;\n"
"	if (spotCos < secondCosCutOff) {\n"
"		attenuation = 0.0;\n"
"	} else {\n"
"		attenuation *= pow(spotCos, DefaultSpotExponent);\n"
"		if (spotCos < lightCosCutOff) {\n"
"			attenuation *= (spotCos - secondCosCutOff) / cutOffFadeOut;\n"
"		}\n"
"	}\n"
"	vec3 L0 = (feiKd * texColor + feiKs * pow(cosThetah, m)) * (El * cosThetai * attenuation);\n"
"	result += L0;\n"
"}\n"
"\n"
"vec4 blur(sampler2D texture, vec2 texCoord, float blurRadius, float sampleNum)\n"
"{\n"
"	if (blurRadius > 0.0 && sampleNum > 1.0) {\n"
"		vec4 col = vec4(0.0);\n"
"		vec2 unit = 1.0 / textureSize(texture, 0);\n"
"\n"
"		float r = blurRadius;\n"
"		float sampleStep = r / sampleNum;\n"
"\n"
"		float count = 0.0;\n"
"\n"
"		for (float x = -r; x < r; x += sampleStep) {\n"
"			for (float y = -r; y < r; y += sampleStep) {\n"
"				float weight = (r - abs(x)) * (r - abs(y));\n"
"				col += texture2D(texture, texCoord + vec2(x * unit.x, y * unit.y)) * weight;\n"
"				count += weight;\n"
"			}\n"
"		}\n"
"		return col / count;\n"
"	}\n"
"	return texture2D(texture, texCoord);\n"
"}\n"
"\n"
"void rgb2hsv(inout vec3 color)\n"
"{\n"
"	float r = color.r;\n"
"	float g = color.g;\n"
"	float b = color.b;\n"
"\n"
"	float M = max(max(r, g), b);\n"
"	float m = min(min(r, g), b);\n"
"	float C = M - m;\n"
"\n"
"	//Hue\n"
"	if (C == 0.0) {\n"
"		color[0] = -eps; //Undefined\n"
"	} else if (M == r) {\n"
"		color[0] = 60.0 * mod((g - b) / C, 6.0);\n"
"	} else if (M == g) {\n"
"		color[0] = 60.0 * (b - r) / C + 120.0;\n"
"	} else if (M == b) {\n"
"		color[0] = 60.0 * (r - g) / C + 240.0;\n"
"	}\n"
"\n"
"	//Saturation\n"
"	color[1] = C / M;\n"
"\n"
"	//Value\n"
"	color[2] = M;\n"
"}\n"
"\n"
"void hsv2rgb(inout vec3 color)\n"
"{\n"
"	float h = color[0];\n"
"	float s = color[1];\n"
"	float v = color[2];\n"
"\n"
"	float C = v * s;\n"
"	float H = h / 60.0;\n"
"	float X = C * (1.0 - abs(mod(H, 2.0) - 1.0));\n"
"	if (H < 0.0) color = vec3(0.0);\n"
"	else if (H < 1.0) color = vec3(C, X, 0.0);\n"
"	else if (H < 2.0) color = vec3(X, C, 0.0);\n"
"	else if (H < 3.0) color = vec3(0.0, C, X);\n"
"	else if (H < 4.0) color = vec3(0.0, X, C);\n"
"	else if (H < 5.0) color = vec3(X, 0.0, C);\n"
"	else color = vec3(C, 0.0, X);\n"
"	color += vec3(v - C);\n"
"}\n"
"\n"
"void rgb2hsl(inout vec3 color)\n"
"{\n"
"	float r = color.r;\n"
"	float g = color.g;\n"
"	float b = color.b;\n"
"\n"
"	float M = max(max(r, g), b);\n"
"	float m = min(min(r, g), b);\n"
"	float C = M - m;\n"
"	float L = (M + m) * 0.5;\n"
"\n"
"	//Hue\n"
"	if (C == 0.0) {\n"
"		color[0] = -eps;\n"
"	} else if (M == r) {\n"
"		color[0] = 60.0 * mod((g - b) / C, 6.0);\n"
"	} else if (M == g) {\n"
"		color[0] = 60.0 * (b - r) / C + 120.0;\n"
"	} else if (M == b) {\n"
"		color[0] = 60.0 * (r - g) / C + 240.0;\n"
"	}\n"
"\n"
"	//Saturation\n"
"	color[1] = C / (1.0 - abs(2.0 * L - 1.0));\n"
"\n"
"	//Luminance\n"
"	color[2] = L;\n"
"}\n"
"\n"
"void hsl2rgb(inout vec3 color)\n"
"{\n"
"	float h = color[0];\n"
"	float s = color[1];\n"
"	float l = color[2];\n"
"\n"
"	float C = (1.0 - abs(2.0 * l - 1.0)) * s;\n"
"	float H = h / 60.0;\n"
"	float X = C * (1.0 - abs(mod(H, 2.0) - 1.0));\n"
"\n"
"	if (H < 0.0) color = vec3(0.0);\n"
"	else if (H < 1.0) color = vec3(C, X, 0.0);\n"
"	else if (H < 2.0) color = vec3(X, C, 0.0);\n"
"	else if (H < 3.0) color = vec3(0.0, C, X);\n"
"	else if (H < 4.0) color = vec3(0.0, X, C);\n"
"	else if (H < 5.0) color = vec3(X, 0.0, C);\n"
"	else color = vec3(C, 0.0, X);\n"
"	color += vec3(l - C * 0.5);\n"
"}\n"
"\n"
"void rgb2linear(inout vec3 rgb)\n"
"{\n"
"	rgb = pow(rgb, vec3(g_gamma));\n"
"}\n"
"\n"
"void linear2rgb(inout vec3 linear)\n"
"{\n"
"	linear = pow(linear, vec3(1.0 / g_gamma));\n"
"}\n"
"\n"
"//Render Pass\n"
"\n"
"void renderPlain()\n"
"{\n"
"	vec4 color = v_color;\n"
"\n"
"	if (feiUseTex) {\n"
"		color *= texture2D(feiTex, v_texcoord);\n"
"		if (color.a == 0.0) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	feiColorOutput = color;\n"
"}\n"
"\n"
"void renderBlur()\n"
"{\n"
"	vec4 color = v_color;\n"
"\n"
"	color *= blur(feiTex, v_texcoord, feiBlurRadius, feiSampleNum);\n"
"	if (color.a == 0.0) {\n"
"		discard;\n"
"	}\n"
"	feiColorOutput = color;\n"
"}\n"
"\n"
"void renderBasic()\n"
"{\n"
"	vec4 color = v_color;\n"
"	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	vec4 emitColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	vec3 normal;\n"
"\n"
"	if (feiUseCullTex) {\n"
"		if (texture2D(feiCullTex, v_texcoord).rgb == vec3(0.0)) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	if (feiUseTex) {\n"
"		vec4 texColor = texture2D(feiTex, v_texcoord);\n"
"		if (texColor.a == 0.0) {\n"
"			discard;\n"
"		}\n"
"		rgb2linear(texColor.rgb);\n"
"		color *= texColor;\n"
"	}\n"
"	if (feiUseEmitTex) {\n"
"		emitColor = texture2D(feiEmitTex, v_texcoord);\n"
"		if (emitColor.a == 0.0) {\n"
"			emitColor.rgb = vec3(0.0);\n"
"		}\n"
"		emitColor.a = 1.0;\n"
"		rgb2linear(emitColor.rgb);\n"
"		emitColor.rgb *= feiEmitValue;\n"
"	}\n"
"	if (feiUseNormalTex) {\n"
"		normal = getNormalFromNormalMap(feiNormalTex, v_texcoord, gl_NormalMatrix);\n"
"	} else {\n"
"		normal = normalize(gl_NormalMatrix * feiNormalValue);\n"
"	}\n"
"	if (feiUseLight) {\n"
"		result.a = color.a;\n"
"		for (int i = 0; i < feiLightNum; i++) {\n"
"			switch (feiLightType[i]) {\n"
"			case POINT_LIGHT:\n"
"				PointLight(result.rgb, color.rgb, normal, feiLightPos[i], feiLightRadius[i], feiLightColor[i].rgb, feiLightColor[i].a);\n"
"				break;\n"
"			case DIRECTIONAL_LIGHT:\n"
"				DirectionalLight(result.rgb, color.rgb, normal, feiLightDirection[i], feiLightColor[i].rgb, feiLightColor[i].a);\n"
"				break;\n"
"			case SPOT_LIGHT:\n"
"				SpotLight(result.rgb, color.rgb, normal, feiLightPos[i], feiLightDirection[i], feiLightRadius[i], DefaultSpotCosCutOff, feiLightColor[i].rgb, feiLightColor[i].a);\n"
"				break;\n"
"			}\n"
"		}\n"
"	} else {\n"
"		result = color;\n"
"	}\n"
"	emitColor.rgb += result.rgb * feiEmitAllValue;\n"
"	result.rgb += emitColor.rgb * (1.0 - feiEmitHaloValue);\n"
"	feiColorOutput = result;\n"
"	linear2rgb(emitColor.rgb);\n"
"	feiEmitOutput = emitColor;\n"
"}\n"
"\n"
"float getLuminance(vec4 color)\n"
"{\n"
"	return dot(vec3(color), LuminanceVector);\n"
"}\n"
"\n"
"float ToneMap(float Lw)\n"
"{\n"
"	float a = 0.18;\n"
"	float Lww = feiLw;\n"
"	float L = a / Lww * Lw;\n"
"	float Ld = L * (1.0 + L / (feiLwhite * feiLwhite)) / (1.0 + L);\n"
"	return Ld;\n"
"}\n"
"\n"
"void renderHDR()\n"
"{\n"
"	vec4 color = texture2D(feiTex, v_texcoord);\n"
"	if (color.a == 0.0) {\n"
"		discard;\n"
"	}\n"
"	linear2rgb(color.rgb);\n"
"	float Lw = getLuminance(color);\n"
"	rgb2linear(color.rgb);\n"
"	float Ld = ToneMap(Lw);\n"
"	color.rgb *= Ld / Lw;\n"
"	feiColorOutput = color;\n"
"}\n"
"\n"
"void renderFinal()\n"
"{\n"
"	vec4 color = v_color;\n"
"	color *= texture2D(feiTex, v_texcoord);\n"
"	vec4 emitColor = texture2D(feiEmitTex, v_texcoord);\n"
"	rgb2linear(emitColor.rgb);\n"
"	color.rgb += emitColor.rgb * feiEmitHaloValue;\n"
"	linear2rgb(color.rgb);\n"
"	feiColorOutput = color;\n"
"}\n"
